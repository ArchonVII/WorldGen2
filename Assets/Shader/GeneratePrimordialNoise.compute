#pragma kernel CSMain

// Include the noise library.
// Make sure this path matches where you installed it in your Packages.
//Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl
#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"

// Our writable output texture (RFloat format)
RWTexture2D<float> _Heightmap;

// Parameters set from C#
int2 _Resolution;
float _Frequency;
float _Amplitude;

// Helper to convert 2D UV to 3D Sphere position
// (This is the HLSL version of your C# math)
float3 UVToSphere(float2 uv)
{
    float theta = uv.x * 3.1415926535 * 2.0;
    float phi = uv.y * 3.1415926535;
    
    float sin_phi = sin(phi);
    
    return float3(
        sin_phi * cos(theta),
        cos(phi),
        sin_phi * sin(theta)
    );
}

// 3D Fractal Noise (Fractal Brownian Motion)
// We build this by layering octaves of noise.
float FractalNoise(float3 p)
{
    float f = _Frequency;
    float a = _Amplitude;
    float total = 0.0;
    
    // 4 octaves of noise
    for (int i = 0; i < 4; i++)
    {
        total += ClassicNoise(p * f) * a;
        f *= 2.0; // Double frequency
        a *= 0.5; // Half amplitude
    }
    
    return total;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get 0-1 UV coordinates for this pixel
    float2 uv = float2(id.x / (float) _Resolution.x, id.y / (float) _Resolution.y);
    
    // Convert to 3D position on the sphere
    float3 p1 = UVToSphere(uv);
    
    // Get the noise value (range -1 to 1)
    float noiseVal = FractalNoise(p1);
    
    // Remap noise from [-1, 1] to [0, 1]
    noiseVal = (noiseVal + 1.0) * 0.5;
    
    // Write the final 0-1 height value to the texture
    _Heightmap[id.xy] = noiseVal;
}
